package femtodb.core.accessor.parameter;import java.util.regex.Pattern;import java.util.regex.Matcher;import java.io.*;import java.util.*;import femtodb.core.*;import femtodb.core.table.*;import femtodb.core.table.data.*;import femtodb.core.table.transaction.*;import femtodb.core.accessor.parameter.*;import femtodb.core.accessor.executor.*;import femtodb.core.accessor.scripts.*;/**  * WhereTypeLikeクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class WhereTypeLike implements IWhereType {    private boolean multiWord = false;    private String[] multiWordList = null;    private Pattern[] multiWordPatternList = null;    private String whereParamStr = null;    private byte[] whereParamStrBytes = null;    private byte whereParamBytesStart = 0;    private byte whereParamBytesEnd = 0;    int count = 0;    private int whereParamStrLen = -1;    private int whereParamStrBytesLen = -1;    private String columnName = null;    private Pattern pattern = null;    private static byte recodeSep = ((byte[])"\n".getBytes())[0];    private Integer[] noDataMap = new Integer[100];    public WhereTypeLike(String columnName, IWhereParameter whereParameter) {        this.columnName = columnName;        whereParamStr = whereParameter.toString();        if (whereParamStr.indexOf("|") != -1) {            multiWordList = whereParamStr.split("\\|");            multiWordPatternList = new Pattern[multiWordList.length];            for (int i = 0; i < multiWordList.length; i++) {                multiWordPatternList[i] = Pattern.compile(multiWordList[i].trim());            }            multiWord = true;        } else {                whereParamStrBytes = whereParamStr.getBytes();            whereParamStrLen = whereParamStr.length();            whereParamStrBytesLen = whereParamStrBytes.length;            whereParamBytesStart = whereParamStrBytes[0];            whereParamBytesEnd = whereParamStrBytes[whereParamStrBytesLen - 1];                        pattern = Pattern.compile(whereParamStr);            for (int idx = 0; idx < whereParamStrBytesLen; idx++) {                noDataMap[((whereParamStrBytes[idx] << 1) >>>1) % 100] = new Integer(1);             }        }    }    public int type() {        return 2;    }    public final boolean execute(TableDataTransfer tableDataTransfer) {        // 複数ワードかチェック        if (multiWord) {            // マルチワード            return multiWordExecute(tableDataTransfer);        } else {            // 1ワード            return singleWordExecute(tableDataTransfer);        }    }    private final boolean singleWordExecute(TableDataTransfer tableDataTransfer) {        String columnData = tableDataTransfer.getColumnData(this.columnName);        if (columnData == null) return false;        Matcher matcher = pattern.matcher(columnData);        if (matcher.find()) {            return true;        } else {            return false;        }    }    private final boolean multiWordExecute(TableDataTransfer tableDataTransfer) {        // 複数ワードなので1度でもHitしたら返す        String columnData = tableDataTransfer.getColumnData(this.columnName);        if (columnData == null) return false;        for (int i = 0; i < multiWordPatternList.length; i++) {            Matcher matcher = multiWordPatternList[i].matcher(columnData);            if (matcher.find()) return true;        }        return false;    }/*    public final void executeAll(TableIterator iterator, TransactionNo transactionNo, List resultList) {        for (; iterator.hasNext();) {            iterator.nextEntry();            TableData tableData = (TableData)iterator.getEntryValue();            TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(transactionNo);            if (tableDataTransfer != null) {                String columnData = tableDataTransfer.getColumnData(this.columnName);                if (columnData == null) continue;                Matcher matcher = pattern.matcher(columnData);                if (matcher.find()) {                    resultList.add(tableDataTransfer);                }            }        }    }*/    public final void executeAll(TableIterator iterator, TransactionNo transactionNo, List resultList) {        // 複数ワードかチェック        if (multiWord) {            // マルチワード            multiWordExecuteAll(iterator, transactionNo, resultList);        } else {            // 1ワード            singleWordExecuteAll(iterator, transactionNo, resultList);        }    }    public final void multiWordExecuteAll(TableIterator iterator, TransactionNo transactionNo, List resultList) {        while (iterator.hasNext()) {            iterator.next();            TableData tableData = (TableData)iterator.getEntryValue();            TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(transactionNo);            if (tableDataTransfer != null) {                if (multiWordExecute(tableDataTransfer)) resultList.add(tableDataTransfer);            }        }    }    public final void singleWordExecuteAll(TableIterator iterator, TransactionNo transactionNo, List resultList) {        ByteArrayOutputStream strBuf = new ByteArrayOutputStream(200000);        int cnt = 0;        TableDataTransfer[] targetData = new TableDataTransfer[1201];        byte[][] targetColData = new byte[1201][];        int[] bufferDataStartPoint = new int[1201];//        List targetData = new ArrayList(1300);        try {            while (iterator.hasNext()) {                    iterator.next();                TableData tableData = (TableData)iterator.getEntryValue();                TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(transactionNo);                if (tableDataTransfer != null) {                        byte[] columnData = tableDataTransfer.getColumnDataBytes(this.columnName);                    if (columnData == null) continue;                        if (cnt < 1200) {                        targetData[cnt] = tableDataTransfer;//                        targetData.add(tableDataTransfer);                        targetColData[cnt] = columnData;//                        targetData.add(columnData);                        bufferDataStartPoint[cnt] = strBuf.size();                        strBuf.write(columnData);                        strBuf.write(recodeSep);                        cnt++;                    } else {                        targetData[cnt] = tableDataTransfer;                        targetColData[cnt] = columnData;                        bufferDataStartPoint[cnt] = strBuf.size();//                        cnt = 0;//                        targetData.add(tableDataTransfer);//                        targetData.add(columnData);                        strBuf.write(columnData);                        strBuf.write(recodeSep);                            int matchPoint = match(strBuf.toByteArray());                        if (matchPoint > -1) {                              int idx = 0;                              if (bufferDataStartPoint[1200] < matchPoint) {                                  idx = 1199;                              } else if (bufferDataStartPoint[1100] < matchPoint) {                                  idx = 1099;                              } else if (bufferDataStartPoint[1000] < matchPoint) {                                  idx = 999;                              } else if (bufferDataStartPoint[900] < matchPoint) {                                  idx = 899;                              } else if (bufferDataStartPoint[800] < matchPoint) {                                  idx = 799;                              } else if (bufferDataStartPoint[700] < matchPoint) {                                  idx = 699;                              } else if (bufferDataStartPoint[600] < matchPoint) {                                  idx = 599;                              } else if (bufferDataStartPoint[500] < matchPoint) {                                  idx = 499;                              } else if (bufferDataStartPoint[400] < matchPoint) {                                  idx = 399;                              } else if (bufferDataStartPoint[300] < matchPoint) {                                  idx = 299;                              } else if (bufferDataStartPoint[200] < matchPoint) {                                  idx = 199;                              } else if (bufferDataStartPoint[100] < matchPoint) {                                  idx = 99;                              }                              for (; idx < (cnt+1); idx++) {                                byte[] colData = (byte[])targetColData[idx];                                    if (colData.length >= whereParamStrBytesLen) {                                    if (matchBytes(colData)) {                                        resultList.add(targetData[idx]);                                    }                                }                            }                        }                        cnt = 0;                        bufferDataStartPoint = new int[1201];//                        targetData.clear();                        strBuf.reset();                                            }                }            }            if (strBuf.size() > 0) {                int matchPoint = match(strBuf.toByteArray());                if (matchPoint > -1) {                    // ここでのcntは上のループで終わらなかったデータの終点インデックスを表していいるため+1しない                    for (int idx = 0; idx < cnt; idx++) {                            byte[] colData = (byte[])targetColData[idx];                            if (colData.length >= whereParamStrBytesLen) {                            if (matchBytes(colData)) {                                resultList.add(targetData[idx]);                            }                        }                    }                }                targetData = null;                strBuf = null;            }        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * byte配列をBM法に探索     */    private boolean matchBytes(byte[] tBytes) {        if (match(tBytes) > -1) return true;        return false;    }    private int match(byte[] tBytes) {        if(tBytes.length < 1) return -1;        int tByteLen = tBytes.length;        if (tByteLen < whereParamStrBytesLen) return -1;        int from = 0;        int to = 0;        while(true) {            if ((from + whereParamStrBytesLen-1) >= tByteLen) return -1;            int move = 0;            if (noDataMap[((tBytes[from+(whereParamStrBytesLen-1)] << 1) >>>1) % 100] == null) {                move = whereParamStrBytesLen;            } else {                for (int idx = whereParamStrBytesLen-1; idx >= 0; idx--) {                    if (tBytes[from+idx] != whereParamStrBytes[idx]) {                        move++;                        break;                    }                }            }            if (move == 0) return from;            from = from + move;        }    }}