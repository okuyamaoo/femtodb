package femtodb.core.accessor.parameter;import java.util.*;import java.io.*;import femtodb.core.*;import femtodb.core.table.*;import femtodb.core.table.data.*;import femtodb.core.table.transaction.*;import femtodb.core.accessor.parameter.*;import femtodb.core.accessor.executor.*;import femtodb.core.accessor.scripts.*;/**  * WhereTypeEqualクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class WhereTypeEqual implements IWhereType {    private String whereParamStr = null;    private byte[] whereParamStrBytes = null;    private byte whereParamStrFirstByte = -1;    private byte whereParamStrEndByte = -1;    private byte whereParamBytesStart = 0;    private byte whereParamBytesEnd = 0;    int count = 0;    private int whereParamStrLen = -1;    private int whereParamStrBytesLen = -1;    private static byte recodeSep = ((byte[])"\n".getBytes())[0];//    private Integer[] noDataMap = new Integer[100];    private String columnName = null;    public WhereTypeEqual(String columnName, IWhereParameter whereParameter) {        this.columnName = columnName;        whereParamStr = whereParameter.toString();        whereParamStrLen = whereParamStr.length();        this.columnName = columnName;        whereParamStrBytes = whereParamStr.getBytes();        whereParamStrBytesLen = whereParamStrBytes.length;        whereParamBytesStart = whereParamStrBytes[0];        whereParamBytesEnd = whereParamStrBytes[whereParamStrBytesLen - 1];        /*        for (int idx = 0; idx < whereParamStrBytesLen; idx++) {            noDataMap[((whereParamStrBytes[idx] << 1) >>>1) % 100] = new Integer(1);         }*/    }    public int type() {        return 1;    }    public final boolean execute(TableDataTransfer tableDataTransfer) {        String columnData = tableDataTransfer.getColumnData(this.columnName);        if (columnData == null) return false;        return columnData.equals(whereParamStr);    }    public final void executeAll(TableIterator iterator, TransactionNo transactionNo, List resultList) {        while (iterator.hasNext()) {            iterator.next();            TableData tableData = (TableData)iterator.getEntryValue();            TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(transactionNo);            if (tableDataTransfer != null) {                byte[] columnData = tableDataTransfer.getColumnDataBytes(this.columnName);                                if (columnData == null ||  columnData.length != whereParamStrBytesLen || columnData[0] != whereParamBytesStart || columnData[columnData.length-1] != whereParamBytesEnd) continue;                if (whereParamStrBytesLen == 1) {                                        resultList.add(tableDataTransfer);                    continue;                }                boolean fullMatch = true;                for (int idx = 1; idx < whereParamStrBytesLen; idx++) {                    if (columnData[idx] != whereParamStrBytes[idx]) {                        fullMatch = false;                        break;                    }                }                                if (!fullMatch) {                    continue;                } else {                    resultList.add(tableDataTransfer);                }            }        }    }/*    public final void executeAll(TableIterator iterator, TransactionNo transactionNo, List resultList) {        ByteArrayOutputStream strBuf = new ByteArrayOutputStream(20000);        int cnt = 0;        int maxAppend = 3000;        TableDataTransfer[] targetData = new TableDataTransfer[maxAppend+1];        byte[][] targetColData = new byte[maxAppend+1][];        int[] bufferDataStartPoint = new int[maxAppend+1];       try {            while (iterator.hasNext()) {                    iterator.next();                TableData tableData = (TableData)iterator.getEntryValue();                TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(transactionNo);                if (tableDataTransfer != null) {                        byte[] columnData = tableDataTransfer.getColumnDataBytes(this.columnName);                    if (columnData == null || columnData.length != whereParamStrBytesLen || columnData[0] != whereParamStrBytes[0]) continue;                    if (whereParamStrBytesLen == 1) {                        resultList.add(tableDataTransfer);                        continue;                    }                    if (cnt < maxAppend) {                        targetData[cnt] = tableDataTransfer;//                        targetData.add(tableDataTransfer);                        targetColData[cnt] = columnData;//                        targetData.add(columnData);                        bufferDataStartPoint[cnt] = strBuf.size();                        strBuf.write(columnData);                        strBuf.write(recodeSep);                        cnt++;                    } else {                        targetData[cnt] = tableDataTransfer;                        targetColData[cnt] = columnData;                        bufferDataStartPoint[cnt] = strBuf.size();//                        cnt = 0;//                        targetData.add(tableDataTransfer);//                        targetData.add(columnData);                        strBuf.write(columnData);                        strBuf.write(recodeSep);                            int matchPoint = match(strBuf.toByteArray());                        if (matchPoint > -1) {                              int idx = 0;                              for (int mIdx = 100; mIdx < (maxAppend - 100); mIdx=mIdx+100) {                                  if (bufferDataStartPoint[mIdx] < matchPoint) {                                      idx = mIdx-1;                                      break;                                  }                              }                              for (; idx < (cnt+1); idx++) {                                byte[] colData = (byte[])targetColData[idx];                                    if (matchBytes(colData)) {                                    resultList.add(targetData[idx]);                                }                            }                        }                        cnt = 0;                        bufferDataStartPoint = new int[maxAppend+1];                        strBuf.reset();                                            }                }            }            if (strBuf.size() > 0) {                int matchPoint = match(strBuf.toByteArray());                if (matchPoint > -1) {                    // ここでのcntは上のループで終わらなかったデータの終点インデックスを表していいるため+1しない                    for (int idx = 0; idx < cnt; idx++) {                            byte[] colData = (byte[])targetColData[idx];                            if (matchBytes(colData)) {                            resultList.add(targetData[idx]);                        }                    }                }                targetData = null;                strBuf = null;            }        } catch (Exception e) {            e.printStackTrace();        }    }*//*    private boolean matchBytes(byte[] tBytes) {        for (int idx = 1; idx < whereParamStrBytesLen; idx++) {            if (tBytes[idx] != whereParamStrBytes[idx]) return false;        }        return true;    }    private int match(byte[] tBytes) {        if(tBytes.length < 1) return -1;        int tByteLen = tBytes.length;        if (tByteLen < whereParamStrBytesLen) return -1;        int from = 0;        int to = 0;        while(true) {            if ((from + whereParamStrBytesLen-1) >= tByteLen) return -1;            int move = 0;            if (noDataMap[((tBytes[from+(whereParamStrBytesLen-1)] << 1) >>>1) % 100] == null) {                move = whereParamStrBytesLen;            } else {                for (int idx = whereParamStrBytesLen-1; idx >= 0; idx--) {                    if (tBytes[from+idx] != whereParamStrBytes[idx]) {                        move++;                        break;                    }                }            }            if (move == 0) return from;            from = from + move;        }    }*/}