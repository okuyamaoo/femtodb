package femtodb.core;import java.util.concurrent.atomic.AtomicLong;/**  * FemtoDBConstantsクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class FemtoDBConstants {    public static boolean isBuilded = false;    //     public static void build(String[] startOptions) {        if (isBuilded == false) {            // 起動引数は "-項目名 値"のフォーマット            StringBuilder strBuf = new StringBuilder();            for (int i = 0; i < startOptions.length; i++) {                strBuf.append(" ");                strBuf.append(startOptions[i]);                // TRANSACTION_LOG_WRITE                if (startOptions[i].trim().equals("-tlw")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            TRANSACTION_LOG_WRITE = true;                        }                    }                }                // TRANSACTION_LOG                if (startOptions[i].trim().equals("-tl")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            TRANSACTION_LOG = startOptions[i+1];                        }                    }                }                // HTTP_SERVER_PORT                if (startOptions[i].trim().equals("-httpport")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int newHttpPort = new Integer(startOptions[i+1]);                                HTTP_SERVER_PORT = newHttpPort;                            } catch (Exception e) {                            }                        }                    }                }                // HTTP_SERVER_MAXTHREADS                if (startOptions[i].trim().equals("-maxclients")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int maxThreads = new Integer(startOptions[i+1]);                                HTTP_SERVER_MAXTHREADS = maxThreads;                            } catch (Exception e) {                            }                        }                    }                }                // HTTP_SERVER_IDLETIMEOUT                if (startOptions[i].trim().equals("-timeout")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int idleTimeout = new Integer(startOptions[i+1]);                                HTTP_SERVER_IDLETIMEOUT = idleTimeout;                            } catch (Exception e) {                            }                        }                    }                }                // STORAGE_MODE                if (startOptions[i].trim().equals("-storage")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("serialize")) {                            STORAGE_MODE = 2;                        }                    }                }                // DB_SYSTEM_LOG                if (startOptions[i].trim().equals("-debug")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            DB_SYSTEM_LOG = true;                        }                    }                }                // indexParallelsNumber                if (startOptions[i].trim().equals("-iqp")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int setIndexParallelsNumber = new Integer(startOptions[i+1]);                                indexParallelsNumber = setIndexParallelsNumber;                                indexParallelsSync = new String[indexParallelsNumber];                                for (int idx = 0; idx < indexParallelsNumber; idx++) {                                    indexParallelsSync[idx] = new Integer(idx).toString();                                }                            } catch (Exception e) {                            }                        }                    }                }                // parameterParallelsNumber                if (startOptions[i].trim().equals("-nqp")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int setParameterParallelsNumber = new Integer(startOptions[i+1]);                                parameterParallelsNumber = setParameterParallelsNumber;                                parameterParallelsSync = new String[parameterParallelsNumber];                                for (int idx = 0; idx < parameterParallelsNumber; idx++) {                                    parameterParallelsSync[idx] = new Integer(idx).toString();                                }                            } catch (Exception e) {                            }                        }                    }                }                // allSearchParallelsNumber                if (startOptions[i].trim().equals("-fqp")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int setAllSearchParallelsNumber = new Integer(startOptions[i+1]);                                allSearchParallelsNumber = setAllSearchParallelsNumber;                                allSearchParallelsSync = new String[allSearchParallelsNumber];                                for (int idx = 0; idx < allSearchParallelsNumber; idx++) {                                    allSearchParallelsSync[idx] = new Integer(idx).toString();                                }                            } catch (Exception e) {                            }                        }                    }                }            }            System.out.println(" System boot parameter =[" + strBuf.toString() +"]");            isBuilded = true;        }    }    /**     * トランザクションログの書き込み要非     */    public static volatile boolean TRANSACTION_LOG_WRITE = false;    /**     * トランザクションログのパス     */    public static volatile String TRANSACTION_LOG = "./femtodb.log";    /**     * FemtoServerをhttpで起動する場合のポート番号     */    public static volatile int HTTP_SERVER_PORT = 8080;    /**     * FemtoServerをhttpで起動する場合の最大同時接続可能数     */    public static volatile int HTTP_SERVER_MAXTHREADS = 400;    /**     * FemtoServerをhttpで起動した場合のクライアントの接続後処理待ち時間     */    public static volatile int HTTP_SERVER_IDLETIMEOUT = 30000;    /**     * FemtoDBの内部ログの出力状態 true=出力/false=非出力     */    public static volatile boolean DB_SYSTEM_LOG = false;    /**      * 内部ストレージモード     * defaultは高速だがメモリを大量に使う     * serializeは高速だがメモリを節約出来る     */    public static volatile int STORAGE_MODE = 1; // 1=default 2=serialize    // インデックス指定が行われているselectクエリーの並列同時実行数    // インデックスを用いた検索は高速なので、並行数を下げても秒間当たりの処理数は稼げる    // なのでここの数値は小さめ。大きくすると1クエリがCPUを専有する時間は短いが並列数が上がり    // CPUを使い果たしてしまうため、その他のインデックスを使わない検索まで遅くなってします    // 稼働サーバのCPU数の約1/2が推奨    // インデックスを使わない検索を全くしない場合はCPU数まで上げることも良いと考える    public static volatile int indexParallelsNumber = 4;    public static volatile AtomicLong indexRequestCount = new AtomicLong(0);    public static volatile Object[] indexParallelsSync = {"1","2","3","4"};    // インデックスではない条件指定が行われているselectクエリーの並列同時実行数    // インデックスを使わない検索はFullScanであるため、CPUの占有率が高い    // なのでここの数値は小さめとする。これはCPUを使い果たさないためである。    // 稼働サーバのCPU数の約1/4が推奨    public static volatile int parameterParallelsNumber = 2;    public static volatile AtomicLong parameterRequestCount = new AtomicLong(0);    public static volatile Object[] parameterParallelsSync = {"1","2"};    // 条件指定が行われていないselectクエリーの並列同時実行数    // 全件取得は全体件数が大きくならない限り、CPUを専有する時間は短い。    // 稼働サーバのCPU数の約1/4が推奨    public static volatile int allSearchParallelsNumber = 1;    public static volatile AtomicLong allSearchRequestCount = new AtomicLong(0);    public static volatile Object[] allSearchParallelsSync = {"1","2"};}