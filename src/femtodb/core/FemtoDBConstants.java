package femtodb.core;import java.io.*;import java.util.concurrent.atomic.AtomicLong;/**  * FemtoDBConstantsクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class FemtoDBConstants {    public static boolean isBuilded = false;    //     public static void build(String[] startOptions) {        if (isBuilded == false) {            // 起動引数は "-項目名 値"のフォーマット            StringBuilder strBuf = new StringBuilder();            for (int i = 0; i < startOptions.length; i++) {                strBuf.append(" ");                strBuf.append(startOptions[i]);                // TRANSACTION_LOG_WRITE                if (startOptions[i].trim().equals("-tlw")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            TRANSACTION_LOG_WRITE = true;                        }                    }                }                // TRANSACTION_LOG                if (startOptions[i].trim().equals("-tl")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            TRANSACTION_LOG = startOptions[i+1];                        }                    }                }                // HTTP_SERVER_PORT                if (startOptions[i].trim().equals("-httpport")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int newHttpPort = Integer.parseInt(startOptions[i+1]);                                HTTP_SERVER_PORT = newHttpPort;                            } catch (Exception e) {                            }                        }                    }                }                // HTTP_SERVER_MAXTHREADS                if (startOptions[i].trim().equals("-maxclients")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int maxThreads = Integer.parseInt(startOptions[i+1]);                                HTTP_SERVER_MAXTHREADS = maxThreads;                            } catch (Exception e) {                            }                        }                    }                }                // HTTP_SERVER_IDLETIMEOUT                if (startOptions[i].trim().equals("-timeout")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int idleTimeout = Integer.parseInt(startOptions[i+1]);                                HTTP_SERVER_IDLETIMEOUT = idleTimeout;                            } catch (Exception e) {                            }                        }                    }                }                // STORAGE_MODE                if (startOptions[i].trim().equals("-storage")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("serialize")) {                            STORAGE_MODE = 2;                        }                    }                }                // DB_SYSTEM_LOG                if (startOptions[i].trim().equals("-debug")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            DB_SYSTEM_LOG = true;                            DB_REQUEST_LOG = true;                            DB_REQUEST_EXECUTION_PRIORITY_LOG = true;                        }                    }                }                // DB_REQUEST_LOG                if (startOptions[i].trim().equals("-querydebug")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            DB_REQUEST_LOG = true;                        }                    }                }                // DB_REQUEST_EXECUTION_PRIORITY_LOG                if (startOptions[i].trim().equals("-qpd")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            DB_REQUEST_EXECUTION_PRIORITY_LOG = true;                        }                    }                }                // indexParallelsNumber                if (startOptions[i].trim().equals("-iqp")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int setIndexParallelsNumber = Integer.parseInt(startOptions[i+1]);                                indexParallelsNumber = setIndexParallelsNumber;                                indexParallelsSync = new String[indexParallelsNumber];                                for (int idx = 0; idx < indexParallelsNumber; idx++) {                                    indexParallelsSync[idx] = Integer.valueOf(idx).toString();                                }                            } catch (Exception e) {                            }                        }                    }                }                // parameterParallelsNumber                if (startOptions[i].trim().equals("-nqp")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int setParameterParallelsNumber = Integer.parseInt(startOptions[i+1]);                                parameterParallelsNumber = setParameterParallelsNumber;                                parameterParallelsSync = new String[parameterParallelsNumber];                                for (int idx = 0; idx < parameterParallelsNumber; idx++) {                                    parameterParallelsSync[idx] = Integer.valueOf(idx).toString();                                }                            } catch (Exception e) {                            }                        }                    }                }                // allSearchParallelsNumber                if (startOptions[i].trim().equals("-fqp")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int setAllSearchParallelsNumber = Integer.parseInt(startOptions[i+1]);                                allSearchParallelsNumber = setAllSearchParallelsNumber;                                allSearchParallelsSync = new String[allSearchParallelsNumber];                                for (int idx = 0; idx < allSearchParallelsNumber; idx++) {                                    allSearchParallelsSync[idx] = Integer.valueOf(idx).toString();                                }                            } catch (Exception e) {                            }                        }                    }                }                // TABLE_AUTO_CREATE                if (startOptions[i].trim().equals("-table_create")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("true")) {                            TABLE_AUTO_CREATE = true;                        }                    }                }                // USER_TEXT_DICTIONARY_PATH                if (startOptions[i].trim().equals("-dictionary")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].trim().equals("")) {                            File file = new File(startOptions[i+1]);                            if (file.isFile()) {                                USER_TEXT_DICTIONARY_PATH = startOptions[i+1];                            } else {                                System.out.println("-dictionary option text file not found");                            }                        }                    }                }                // QUERY_MEMORY_CTL                if (startOptions[i].trim().equals("-qmc")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("false")) {                            QUERY_MEMORY_CTL = false;                        }                    }                }                // JVM_OLD_SPACE_USE_LIMIT                if (startOptions[i].trim().equals("-josul")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int jvmOldSpaceLimit = Integer.parseInt(startOptions[i+1]);                                JVM_OLD_SPACE_USE_LIMIT = jvmOldSpaceLimit;                            } catch (Exception e) {                            }                        }                    }                }                // USE_RESULT_CACHE                if (startOptions[i].trim().equals("-cache")) {                    if (startOptions.length > (i+1)) {                        if (startOptions[i+1].equals("false")) {                                                        USE_RESULT_CACHE = false;                        }                    }                }                // MAX_RESULT_CACHE_LIMIT                if (startOptions[i].trim().equals("-maxcache")) {                    if (startOptions.length > (i+1)) {                        if (!startOptions[i+1].equals("")) {                            try {                                int maxCache = Integer.parseInt(startOptions[i+1]);                                MAX_RESULT_CACHE_LIMIT = maxCache;                            } catch (Exception e) {                            }                        }                    }                }            }            System.out.println(" System boot parameter =[" + strBuf.toString() +"]");            isBuilded = true;        }    }    /**     * トランザクションログの書き込み要非     */    public static volatile boolean TRANSACTION_LOG_WRITE = false;    /**     * トランザクションログのパス     */    public static volatile String TRANSACTION_LOG = "./femtodb.log";    /**     * FemtoServerをhttpで起動する場合のポート番号     */    public static volatile int HTTP_SERVER_PORT = 8080;    /**     * FemtoServerをhttpで起動する場合の最大同時接続可能数     */    public static volatile int HTTP_SERVER_MAXTHREADS = 400;    /**     * FemtoServerをhttpで起動した場合のクライアントの接続後処理待ち時間     */    public static volatile int HTTP_SERVER_IDLETIMEOUT = 30000;    /**      * JSONPサーバ起動有無     */    public static volatile boolean START_JSONP_SERVER = false;    /**      * JSONPサーバを起動する場合の最大同時接続可能数     */    public static volatile int HTTP_JSONP_SERVER_MAXTHREADS = 400;    /**      * JSONPサーバを起動する場合のポート番号     */    public static volatile int HTTP_JSONP_SERVER_PORT = 80;    /**      * JSONPサーバの接続タイムアウト時間     */    public static volatile int HTTP_JSONP_SERVER_IDLETIMEOUT = 30000;    /**     * FemtoDBの内部ログの出力状態 true=出力/false=非出力     */    public static volatile boolean DB_SYSTEM_LOG = false;    /**     * FemtoDBのリクエストログの出力状態 true=出力/false=非出力     */    public static volatile boolean DB_REQUEST_LOG = false;    /**     * FemtoDBのリクエストの実行優先度の出力状態 true=出力/false=非出力     */    public static volatile boolean DB_REQUEST_EXECUTION_PRIORITY_LOG = false;    /**      * 内部ストレージモード     * defaultは高速だがメモリを大量に使う     * serializeは低速だがメモリを節約出来る     */    public static volatile int STORAGE_MODE = 1; // 1=default 2=serialize    // インデックス指定が行われているselectクエリーの並列同時実行数    // インデックスを用いた検索は高速なので、並行数を下げても秒間当たりの処理数は稼げる    // なのでここの数値は小さめ。大きくすると1クエリがCPUを専有する時間は短いが並列数が上がり    // CPUを使い果たしてしまうため、その他のインデックスを使わない検索まで遅くなってします    // 稼働サーバのCPU数が推奨    // インデックスを使わない検索を全くしない場合はCPU数まで上げることも良いと考える    public static volatile int indexParallelsNumber = 4;    public static volatile AtomicLong indexRequestCount = new AtomicLong(0);    public static volatile Object[] indexParallelsSync = {"1","2","3","4"};    // インデックスではない条件指定が行われているselectクエリーの並列同時実行数    // インデックスを使わない検索はFullScanであるため、CPUの占有率が高い    // なのでここの数値は小さめとする。これはCPUを使い果たさないためである。    // 稼働サーバのCPU数の約1/2が推奨    public static volatile int parameterParallelsNumber = 2;    public static volatile AtomicLong parameterRequestCount = new AtomicLong(0);    public static volatile Object[] parameterParallelsSync = {"1","2"};    // 条件指定が行われていないselectクエリーの並列同時実行数    // 全件取得は全体件数が大きくならない限り、CPUを専有する時間は短い。    // 稼働サーバのCPU数の約1/2が推奨    public static volatile int allSearchParallelsNumber = 2;    public static volatile AtomicLong allSearchRequestCount = new AtomicLong(0);    public static volatile Object[] allSearchParallelsSync = {"1","2"};    // ----------- Query parameter area - start---------------------    public static volatile boolean TABLE_AUTO_CREATE = false;    public static volatile Object TABLE_CREATE_OBJ = new Object();    // ----------- Query parameter area - end  ---------------------    // 検索用ユーザ辞書    public static volatile String USER_TEXT_DICTIONARY_PATH = null;    // JVMのOld領域の利用率の閾値を超えた場合の制御有無。trueとするとold領域が閾値以上になると実行クエリを少しづつ止めてnew領域上のオブジェクトの発生速度を落とす    public static volatile boolean QUERY_MEMORY_CTL = true;    // JVMのOld領域の利用率の閾値。この値を超えると各Queryのスレッドのスループットが落とされJVMのOld領域の掃除が優先される    public static volatile int JVM_OLD_SPACE_USE_LIMIT = 92;    // HTTPでの検索リクエスト時の結果キャッシュの有無    public static volatile boolean USE_RESULT_CACHE = true;    // HTTPでの検索リクエスト時の結果キャッシュの最大数    public static volatile int MAX_RESULT_CACHE_LIMIT = 1000;    // DBが停止時にtrueとなる    public static volatile boolean FEMTODB_STOP = false;}