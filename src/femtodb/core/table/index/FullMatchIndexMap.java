package femtodb.core.table.index;import java.io.*;import java.util.*;import java.util.concurrent.*;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;import femtodb.core.table.data.*;import femtodb.core.util.*;import femtodb.core.table.transaction.*;/**  * FullMatchIndexMapクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class FullMatchIndexMap implements IndexMap, Serializable {    private String indexColumnName = null;    private Comparator comparator = null;    private ConcurrentSkipListMap<String, Map<Long, IndexStruct>> baseMap = null;    private DataMap dataMap = null;    private ReadWriteLock lock = new ReentrantReadWriteLock(true);    private Lock readLock = lock.readLock();    private Lock writeLock = lock.writeLock();    public FullMatchIndexMap(String indexColumnName, Comparator comparator, DataMap dataMap) {        this.indexColumnName = indexColumnName;        this.comparator = comparator;        this.baseMap = new ConcurrentSkipListMap(comparator);        this.dataMap = dataMap;    }    public void putData(TransactionNo tn, long oid, TableData tableData) {        writeLock.lock();        try {            TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(tn);            if (tableDataTransfer == null) return;            String indexColumnData = tableDataTransfer.getColumnData(indexColumnName);            if(indexColumnData == null) return;            Map targetGroup = this.baseMap.get(indexColumnData);            if (targetGroup == null) {                targetGroup = new ConcurrentHashMap<Long, IndexStruct>();                this.baseMap.put(indexColumnData, targetGroup);            }            targetGroup.put(oid, new IndexStruct(tn, tableData));        } finally {            writeLock.unlock();        }    }    public Map<Long, IndexStruct> getIndexGroup(String columnParameter) {        readLock.lock();        try {            Map<Long, IndexStruct> targetGroup = this.baseMap.get(columnParameter);            return targetGroup;        } finally {            readLock.unlock();        }    }    public boolean rebuildIndex() {        Iterator iterator = this.baseMap.entrySet().iterator();        long cnt = 0;        while(iterator.hasNext()) {            Map.Entry<String, Map<Long, IndexStruct>> entry = (Map.Entry<String, Map<Long, IndexStruct>>)iterator.next();            String baseMapKey = entry.getKey();            Map<Long, IndexStruct> targetGroup = entry.getValue();            Iterator targetIterator = targetGroup.entrySet().iterator();            while(targetIterator.hasNext()) {                cnt++;                if ((cnt % 100) == 0) Thread.yield();                Map.Entry targetEntry = (Map.Entry)targetIterator.next();                                writeLock.lock();                try {                    // 保持しているTableDataが該当Index位置のデータでそのデータが作成されたのが、                    // 現在データ及び、旧データの両方のトランザクションNoと違う場合は不用データのため削除する                    Long indexOid = (Long)targetEntry.getKey();                    IndexStruct indexStruct = (IndexStruct)targetEntry.getValue();                    long putTransactionNo = indexStruct.getTransactionNo();                    TableData targetTableData = indexStruct.getTableData();                    if (targetTableData.getNewData() != null && targetTableData.getOldData() == null) {                                            if (putTransactionNo != targetTableData.getNewData().getTransactionNo().getTransactionNo()) {                            // 該当Index削除                            targetGroup.remove(indexOid);                        }                    } else if (targetTableData.getNewData() == null && targetTableData.getOldData() != null) {                        if (putTransactionNo != targetTableData.getOldData().getTransactionNo().getTransactionNo()) {                            // 該当Index削除                            targetGroup.remove(indexOid);                        }                    } else if (putTransactionNo != targetTableData.getNewData().getTransactionNo().getTransactionNo() &&                                putTransactionNo != targetTableData.getOldData().getTransactionNo().getTransactionNo()) {                        // 該当Index削除                        targetGroup.remove(indexOid);                    } else if ((targetTableData.getNewData() != null && targetTableData.getNewData().isDeletedData() == true && targetTableData.getNewData().getTransactionNo().isCommited() == true) ||                               (targetTableData.getOldData() != null && targetTableData.getOldData().isDeletedData() == true && targetTableData.getOldData().getTransactionNo().isCommited() == true)) {                        // 該当データがcommit済みdeleteデータの場合不用データのため削除                        targetGroup.remove(indexOid);                    }                                    } finally {                    writeLock.unlock();                }            }            writeLock.lock();            try {                if (targetGroup.size() == 0) {                    this.baseMap.remove(baseMapKey);                }            } finally {                writeLock.unlock();            }                    }        //SystemLog.println(baseMap);        return true;    }    public String toString() {        return "indexColumnName='" + indexColumnName +"' baseMap=" + baseMap.toString();    }}