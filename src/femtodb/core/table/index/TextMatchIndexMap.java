package femtodb.core.table.index;import java.util.*;import java.util.concurrent.*;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;import org.atilika.kuromoji.Token;import org.atilika.kuromoji.Tokenizer;import femtodb.core.util.*;import femtodb.core.table.data.*;import femtodb.core.table.transaction.*;/**  * TextMatchIndexMapクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class TextMatchIndexMap implements IndexMap {    private String indexColumnName = null;    private Comparator comparator = null;    private ConcurrentSkipListMap<String, Map<Long, IndexStruct>> baseMap = null;    private Map<Long, TableData> dataMap = null;    // kuromojiを使ったTokenizer    private Tokenizer tokenizer = null;    private ReadWriteLock lock = new ReentrantReadWriteLock(true);    private Lock readLock = lock.readLock();    private Lock writeLock = lock.writeLock();    public TextMatchIndexMap(String indexColumnName, Comparator comparator, Map<Long, TableData> dataMap) {        this.indexColumnName = indexColumnName;        this.comparator = comparator;        this.baseMap = new ConcurrentSkipListMap(comparator);        this.dataMap = dataMap;        this.tokenizer = Tokenizer.builder().build();    }    public void putData(TransactionNo tn, long oid, TableData tableData) {        writeLock.lock();        try {            TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(tn);            if (tableDataTransfer == null) return;            String indexColumnData = tableDataTransfer.getColumnData(indexColumnName);            if(indexColumnData == null) return;            List<Token> tokens = tokenizer.tokenize(indexColumnData);            for (Token token : tokens) {                String tokenStr = token.getSurfaceForm();                Map targetGroup = this.baseMap.get(tokenStr);                if (targetGroup == null) {                    targetGroup = new ConcurrentHashMap<Long, IndexStruct>();                    this.baseMap.put(tokenStr, targetGroup);                }                targetGroup.put(oid, new IndexStruct(tn, tableData));            }        } finally {            writeLock.unlock();        }    }    public Map<Long, IndexStruct> getIndexGroup(String columnParameter) {        readLock.lock();        try {            // ユーザ指定のワードでIndexを探す            Map<Long, IndexStruct> targetGroup = this.baseMap.get(columnParameter);            if (targetGroup == null) {                // Indexが見つからない場合はワードを形態素解析し、最初の語句を使う                List<Token> tokens = tokenizer.tokenize(columnParameter);                if (tokens.size() > 0) {                    Token token = tokens.get(0);                    String tokenStr = token.getSurfaceForm();                    targetGroup = this.baseMap.get(tokenStr);                }            }            return targetGroup;        } finally {            readLock.unlock();        }    }    public boolean rebuildIndex() {        Iterator iterator = this.baseMap.entrySet().iterator();        while(iterator.hasNext()) {            Map.Entry<String, Map<Long, IndexStruct>> entry = (Map.Entry<String, Map<Long, IndexStruct>>)iterator.next();            String baseMapKey = entry.getKey();            Map<Long, IndexStruct> targetGroup = entry.getValue();            Iterator targetIterator = targetGroup.entrySet().iterator();            while(targetIterator.hasNext()) {                Map.Entry targetEntry = (Map.Entry)targetIterator.next();                                writeLock.lock();                try {                    // 保持しているTableDataが該当Index位置のデータでそのデータが作成されたのが、                    // 現在データ及び、旧データの両方のトランザクションNoと違う場合は不用データのため削除する                    Long indexOid = (Long)targetEntry.getKey();                    IndexStruct indexStruct = (IndexStruct)targetEntry.getValue();                    long putTransactionNo = indexStruct.getTransactionNo();                    TableData targetTableData = indexStruct.getTableData();                    if (putTransactionNo != targetTableData.getNewData().getTransactionNo().getTransactionNo() &&                            putTransactionNo != targetTableData.getOldData().getTransactionNo().getTransactionNo()) {                        // 該当Index削除                        targetGroup.remove(indexOid);                    } else if ((targetTableData.getNewData() != null && targetTableData.getNewData().isDeletedData() == true && targetTableData.getNewData().getTransactionNo().isCommited() == true) ||                               (targetTableData.getOldData() != null && targetTableData.getOldData().isDeletedData() == true && targetTableData.getOldData().getTransactionNo().isCommited() == true)) {                        // 該当データがcommit済みdeleteデータの場合不用データのため削除                        targetGroup.remove(indexOid);                    }                                    } finally {                    writeLock.unlock();                }            }            writeLock.lock();            try {                if (targetGroup.size() == 0) {                    this.baseMap.remove(baseMapKey);                }            } finally {                writeLock.unlock();            }                    }        //SystemLog.println(baseMap);        return true;    }    public String toString() {        return "indexColumnName='" + indexColumnName +"' baseMap=" + baseMap.toString();    }}