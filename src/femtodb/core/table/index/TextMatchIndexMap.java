package femtodb.core.table.index;import java.io.*;import java.util.*;import java.util.concurrent.*;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReadWriteLock;import java.util.concurrent.locks.ReentrantReadWriteLock;import org.atilika.kuromoji.*;import org.atilika.kuromoji.Tokenizer.*;import femtodb.core.*;import femtodb.core.util.*;import femtodb.core.table.data.*;import femtodb.core.table.transaction.*;/**  * TextMatchIndexMapクラス<br> * * @author Takahiro Iwase * @license Apache License 2.0  */public class TextMatchIndexMap implements IndexMap, Serializable {    private String indexColumnName = null;    private Comparator comparator = null;    private Map<String, Map<Long, IndexStruct>> baseMap = null;    private DataMap dataMap = null;    // kuromojiを使ったTokenizer    private transient Tokenizer tokenizer = null;    private Integer sync = new Integer(1);    private ReadWriteLock lock = new ReentrantReadWriteLock(true);    private Lock readLock = lock.readLock();    private Lock writeLock = lock.writeLock();    public TextMatchIndexMap(String indexColumnName, Comparator comparator, DataMap dataMap) {        this.indexColumnName = indexColumnName;        this.comparator = comparator;        this.baseMap = new ConcurrentSkipListMap(comparator);        //this.baseMap = new IndexCache(210);        this.dataMap = dataMap;    }    private void buildTokenizer() {        if (tokenizer == null) {            try {                synchronized(sync) {                    if (tokenizer == null) {                        Builder builder = Tokenizer.builder();                        if (FemtoDBConstants.USER_TEXT_DICTIONARY_PATH != null) {                            builder.userDictionary(FemtoDBConstants.USER_TEXT_DICTIONARY_PATH);                        }                        this.tokenizer = builder.build();                    }                }            } catch (Exception e) {                e.printStackTrace();            }        }    }    public void putData(TransactionNo tn, long oid, TableData tableData) {        buildTokenizer();        writeLock.lock();        try {            TableDataTransfer tableDataTransfer = tableData.getTableDataTransfer(tn);            if (tableDataTransfer == null) return;            String indexColumnData = tableDataTransfer.getColumnData(indexColumnName);            if(indexColumnData == null) return;            List<Token> tokens = tokenizer.tokenize(indexColumnData);            for (Token token : tokens) {                String tokenStr = token.getSurfaceForm();                Map targetGroup = this.baseMap.get(tokenStr);                if (targetGroup == null) {                    targetGroup = new ConcurrentHashMap<Long, IndexStruct>();                    this.baseMap.put(tokenStr, targetGroup);                }                targetGroup.put(oid, new IndexStruct(tn, tableData));            }        } finally {            writeLock.unlock();        }    }    public Map<Long, IndexStruct> getIndexGroup(String columnParameter) {        buildTokenizer();        boolean multiWord = false;        String[] wordList = null;        // TODO:以下の構文は複数語句対応用        if (columnParameter.indexOf("|") != -1) {            multiWord = true;            wordList = columnParameter.split("\\|");            for (int i = 0; i < wordList.length; i++) {                wordList[i] = wordList[i].trim();            }        }        readLock.lock();        try {            // ユーザ指定のワードでIndexを探す            if (multiWord == false) {                Map<Long, IndexStruct> targetGroup = this.baseMap.get(columnParameter);                    if (targetGroup == null) {                    // Indexが見つからない場合はワードを形態素解析し、最初の語句を使う                    List<Token> tokens = tokenizer.tokenize(columnParameter);                    if (tokens.size() > 0) {                        Token token = tokens.get(0);                        String tokenStr = token.getSurfaceForm();                        targetGroup = this.baseMap.get(tokenStr);                    }                }                return targetGroup;            } else {                // 複数語句検索                Map<Long, IndexStruct> margeTargetGroup = new HashMap();                for (String word : wordList) {                    Map<Long, IndexStruct> targetGroup = this.baseMap.get(word);                    if (targetGroup == null) {                        // Indexが見つからない場合はワードを形態素解析し、最初の語句を使う                        List<Token> tokens = tokenizer.tokenize(word);                        if (tokens.size() > 0) {                            Token token = tokens.get(0);                            String tokenStr = token.getSurfaceForm();                            targetGroup = this.baseMap.get(tokenStr);                        }                    }                    if (targetGroup != null && targetGroup.size() > 0) {                        margeTargetGroup.putAll(targetGroup);                    }                }                if (margeTargetGroup.size() > 0) return margeTargetGroup;                 return null;            }        } finally {            readLock.unlock();        }    }    public boolean rebuildIndex() {        buildTokenizer();        Iterator iterator = this.baseMap.entrySet().iterator();        long cnt = 0;        while(iterator.hasNext()) {            Map.Entry<String, Map<Long, IndexStruct>> entry = (Map.Entry<String, Map<Long, IndexStruct>>)iterator.next();            String baseMapKey = entry.getKey();            Map<Long, IndexStruct> targetGroup = entry.getValue();            Iterator targetIterator = targetGroup.entrySet().iterator();            while(targetIterator.hasNext()) {                cnt++;                if ((cnt % 100) == 0) Thread.yield();                Map.Entry targetEntry = (Map.Entry)targetIterator.next();                                writeLock.lock();                try {                    // 保持しているTableDataが該当Index位置のデータでそのデータが作成されたのが、                    // 現在データ及び、旧データの両方のトランザクションNoと違う場合は不用データのため削除する                    Long indexOid = (Long)targetEntry.getKey();                    IndexStruct indexStruct = (IndexStruct)targetEntry.getValue();                    long putTransactionNo = indexStruct.getTransactionNo();                    TableData targetTableData = indexStruct.getTableData();                    if (targetTableData.getNewData() != null && targetTableData.getOldData() == null) {                                            if (putTransactionNo != targetTableData.getNewData().getTransactionNo().getTransactionNo()) {                            // 該当Index削除                            targetGroup.remove(indexOid);                        }                    } else if (targetTableData.getNewData() == null && targetTableData.getOldData() != null) {                        if (putTransactionNo != targetTableData.getOldData().getTransactionNo().getTransactionNo()) {                            // 該当Index削除                            targetGroup.remove(indexOid);                        }                    } else if (putTransactionNo != targetTableData.getNewData().getTransactionNo().getTransactionNo() &&                                putTransactionNo != targetTableData.getOldData().getTransactionNo().getTransactionNo()) {                        // 該当Index削除                        targetGroup.remove(indexOid);                    } else if ((targetTableData.getNewData() != null && targetTableData.getNewData().isDeletedData() == true && targetTableData.getNewData().getTransactionNo().isCommited() == true) ||                               (targetTableData.getOldData() != null && targetTableData.getOldData().isDeletedData() == true && targetTableData.getOldData().getTransactionNo().isCommited() == true)) {                        // 該当データがcommit済みdeleteデータの場合不用データのため削除                        targetGroup.remove(indexOid);                    }                                    } finally {                    writeLock.unlock();                }            }            writeLock.lock();            try {                if (targetGroup.size() == 0) {                    this.baseMap.remove(baseMapKey);                }            } finally {                writeLock.unlock();            }                    }        //SystemLog.println(baseMap);        return true;    }    public String toString() {        return "indexColumnName='" + indexColumnName +"' baseMap=" + baseMap.toString();    }}