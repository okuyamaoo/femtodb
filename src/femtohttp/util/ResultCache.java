package femtohttp.util;import java.util.*;import java.lang.ref.*;import java.util.concurrent.*;import java.util.concurrent.atomic.*;import java.util.concurrent.locks.*;import femtodb.core.accessor.parameter.*;public class ResultCache extends LinkedHashMap<String, SoftReference> {    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    private final Lock rLock = lock.readLock();    private final Lock wLock = lock.writeLock();    private Map<String, AtomicLong> lastAccessTableTime = new ConcurrentHashMap(30);    private int maxCapacity = 1024;    public ResultCache() {        super(100, 0.75f, true);    }        public ResultCache(int capacity) {        super(capacity, 0.75f, true);        this.maxCapacity = capacity;    }    public void updateTableAccess(String tableName) {        if (lastAccessTableTime.containsKey(tableName)) {            wLock.lock();            try {                AtomicLong tableUpdateCnt = lastAccessTableTime.get(tableName);                tableUpdateCnt.incrementAndGet();            } finally {                wLock.unlock();             }        } else {            wLock.lock();            try {                if (!lastAccessTableTime.containsKey(tableName)) {                    AtomicLong tableUpdateCnt = new AtomicLong(1L);                    lastAccessTableTime.put(tableName, tableUpdateCnt);                }            } finally {                wLock.unlock();             }        }    }    /**     * set<br>     *     * @param key     * @param value     */    public Object put(SelectParameter key, Object value) {        wLock.lock();        try {            AtomicLong tableUpdateCnt = lastAccessTableTime.get(key.getTableName());            if (tableUpdateCnt == null) {                tableUpdateCnt = new AtomicLong(1L);                lastAccessTableTime.put(key.getTableName(), tableUpdateCnt);            }            return super.put(key.toString(), new SoftReference(new CacheStruct(value, tableUpdateCnt.longValue())));        } finally {            wLock.unlock();         }    }    /**     * get<br>     *     * @param key     * @return Object     */    public Object get(SelectParameter key) {        rLock.lock();        try {            SoftReference dataRef = super.get(key.toString());            if (dataRef != null) {                CacheStruct cacheStruct = (CacheStruct)dataRef.get();                if (cacheStruct != null) {                    AtomicLong tableUpdateCnt = lastAccessTableTime.get(key.getTableName());                    if (tableUpdateCnt != null) {                        if (cacheStruct.getVersion() == tableUpdateCnt.longValue()) {                            return cacheStruct.getCache();                        }                    }                }            }            return null;        } finally {             rLock.unlock();         }    }    /**     * remove<br>     *     * @param key     * @return Object     */    public Object remove(SelectParameter key) {        wLock.lock();        try {            return super.remove(key.toString());        } finally {            wLock.unlock();         }    }    /**     * 削除指標実装.<br>     */    protected boolean removeEldestEntry(Map.Entry eldest) {        if (maxCapacity < super.size()) {            return true;        }        return false;    }    class CacheStruct {            Object cache = null;        long version = -1L;                CacheStruct(Object cache, long version) {            this.cache = cache;            this.version = version;        }        public Object getCache() {            return this.cache;        }        public long getVersion() {            return this.version;        }    }}